模型选型总结

- `clarify.toml` (澄清) 和 `constitution.toml` (规约)

  - 任务: 这两个指令主要处理对话、规则检查和简单文本更新。clarify 通过问答减少需求模糊性,constitution
    负责更新和同步项目原则。它们不涉及复杂的代码生成或深度逻辑推理。
  - 模型推荐: 轻量级、高性价比的模型 (如 Gemini 1.5 Flash)。
  - 原因: 这类任务对模型的编程能力要求不高,但需要快速响应和良好的对话理解能力。使用更经济的模型可以在保证效果的同时,显著降低成本和延迟。

- `specify.toml` (规约), `plan.toml` (计划), `analyze.toml` (分析) 和 `tasks.toml` (任务)

  - 任务:
    - specify: 将自然语言需求转化为详细的技术规格。
    - plan: 基于规格创建高阶的架构设计和技术方案。
    - analyze: 在多个文档间进行交叉分析,找出不一致和缺失。
    - tasks: 将高级计划分解为具体、可执行的编码任务列表。
  - 模型推荐: 能力强、具备深度推理和长上下文能力的高级模型 (如 Gemini 1.5 Pro)。
  - 原因: 这些步骤是衔接“想法”和“代码”的关键环节。它们需要模型具备强大的逻辑推理、信息整合、规划和分解能力。特别是 tasks 和 analyze
    指令,需要处理和理解多个文档(spec, plan, data-model 等)的全部内容,因此巨大的上下文窗口至关重要,可以避免因信息不全导致的规划错误。

- `implement.toml` (实现)
  - 任务: 这是最终执行编码的步骤,直接编写或修改代码文件。
  - 模型推荐: 最顶级的、编程能力最强的模型 (如 Gemini 1.5 Pro 或未来更强的模型)。
  - 原因: 这是对模型代码质量、遵循指令精确度、逻辑严谨性要求最高的一步。任何一点小错误都可能导致 bug
    或编译失败。因此,应该不计成本地使用当前最强大的编程模型,以确保最终产出的代码质量最高、最可靠。

总结表

| 指令文件          | 核心任务           | 关键能力要求         | 推荐模型类型   | 成本考量 |
| ----------------- | ------------------ | -------------------- | -------------- | -------- |
| clarify.toml      | 问答、澄清需求     | 对话、快速响应       | 轻量级 (Flash) | 优先     |
| constitution.toml | 规则检查、文本更新 | 分类、遵循模板       | 轻量级 (Flash) | 优先     |
| specify.toml      | 需求转技术规格     | 深度理解、信息组织   | 高级 (Pro)     | 效果优先 |
| plan.toml         | 制定架构和方案     | 宏观规划、逻辑推理   | 高级 (Pro)     | 效果优先 |
| analyze.toml      | 跨文档一致性分析   | 长上下文、深度推理   | 高级 (Pro)     | 效果优先 |
| tasks.toml        | 计划分解为任务     | 长上下文、任务拆解   | 高级 (Pro)     | 效果优先 |
| implement.toml    | 编写/修改代码      | 顶级编程能力、精确性 | 最强模型 (Pro) | 效果至上 |

简单来说,流程可以分为三个阶段:

1.  预处理和规范化 (`clarify`, `constitution`): 使用快速、经济的模型。
2.  核心规划和设计 (`specify`, `plan`, `analyze`, `tasks`): 使用具备长上下文和强大推理能力的高级模型。
3.  编码实现 (`implement`): 使用编程能力最强的顶级模型。

这样的模型组合策略可以在确保项目质量的同时,最大化地优化成本效益。
